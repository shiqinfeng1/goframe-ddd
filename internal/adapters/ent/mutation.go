// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/shiqinfeng1/goframe-ddd/internal/adapters/ent/predicate"
	"github.com/shiqinfeng1/goframe-ddd/internal/adapters/ent/recvchunk"
	"github.com/shiqinfeng1/goframe-ddd/internal/adapters/ent/recvfile"
	"github.com/shiqinfeng1/goframe-ddd/internal/adapters/ent/sendchunk"
	"github.com/shiqinfeng1/goframe-ddd/internal/adapters/ent/sendfile"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeRecvChunk = "RecvChunk"
	TypeRecvFile  = "RecvFile"
	TypeSendChunk = "SendChunk"
	TypeSendFile  = "SendFile"
)

// RecvChunkMutation represents an operation that mutates the RecvChunk nodes in the graph.
type RecvChunkMutation struct {
	config
	op               Op
	typ              string
	id               *int
	chunk_index      *int
	addchunk_index   *int
	chunk_offset     *int64
	addchunk_offset  *int64
	chunk_size       *int
	addchunk_size    *int
	updated_at       *time.Time
	created_at       *time.Time
	clearedFields    map[string]struct{}
	recv_file        *int
	clearedrecv_file bool
	done             bool
	oldValue         func(context.Context) (*RecvChunk, error)
	predicates       []predicate.RecvChunk
}

var _ ent.Mutation = (*RecvChunkMutation)(nil)

// recvchunkOption allows management of the mutation configuration using functional options.
type recvchunkOption func(*RecvChunkMutation)

// newRecvChunkMutation creates new mutation for the RecvChunk entity.
func newRecvChunkMutation(c config, op Op, opts ...recvchunkOption) *RecvChunkMutation {
	m := &RecvChunkMutation{
		config:        c,
		op:            op,
		typ:           TypeRecvChunk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecvChunkID sets the ID field of the mutation.
func withRecvChunkID(id int) recvchunkOption {
	return func(m *RecvChunkMutation) {
		var (
			err   error
			once  sync.Once
			value *RecvChunk
		)
		m.oldValue = func(ctx context.Context) (*RecvChunk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecvChunk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecvChunk sets the old RecvChunk of the mutation.
func withRecvChunk(node *RecvChunk) recvchunkOption {
	return func(m *RecvChunkMutation) {
		m.oldValue = func(context.Context) (*RecvChunk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecvChunkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecvChunkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecvChunkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecvChunkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecvChunk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRecvfileID sets the "recvfile_id" field.
func (m *RecvChunkMutation) SetRecvfileID(i int) {
	m.recv_file = &i
}

// RecvfileID returns the value of the "recvfile_id" field in the mutation.
func (m *RecvChunkMutation) RecvfileID() (r int, exists bool) {
	v := m.recv_file
	if v == nil {
		return
	}
	return *v, true
}

// OldRecvfileID returns the old "recvfile_id" field's value of the RecvChunk entity.
// If the RecvChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvChunkMutation) OldRecvfileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecvfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecvfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecvfileID: %w", err)
	}
	return oldValue.RecvfileID, nil
}

// ResetRecvfileID resets all changes to the "recvfile_id" field.
func (m *RecvChunkMutation) ResetRecvfileID() {
	m.recv_file = nil
}

// SetChunkIndex sets the "chunk_index" field.
func (m *RecvChunkMutation) SetChunkIndex(i int) {
	m.chunk_index = &i
	m.addchunk_index = nil
}

// ChunkIndex returns the value of the "chunk_index" field in the mutation.
func (m *RecvChunkMutation) ChunkIndex() (r int, exists bool) {
	v := m.chunk_index
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkIndex returns the old "chunk_index" field's value of the RecvChunk entity.
// If the RecvChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvChunkMutation) OldChunkIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkIndex: %w", err)
	}
	return oldValue.ChunkIndex, nil
}

// AddChunkIndex adds i to the "chunk_index" field.
func (m *RecvChunkMutation) AddChunkIndex(i int) {
	if m.addchunk_index != nil {
		*m.addchunk_index += i
	} else {
		m.addchunk_index = &i
	}
}

// AddedChunkIndex returns the value that was added to the "chunk_index" field in this mutation.
func (m *RecvChunkMutation) AddedChunkIndex() (r int, exists bool) {
	v := m.addchunk_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkIndex resets all changes to the "chunk_index" field.
func (m *RecvChunkMutation) ResetChunkIndex() {
	m.chunk_index = nil
	m.addchunk_index = nil
}

// SetChunkOffset sets the "chunk_offset" field.
func (m *RecvChunkMutation) SetChunkOffset(i int64) {
	m.chunk_offset = &i
	m.addchunk_offset = nil
}

// ChunkOffset returns the value of the "chunk_offset" field in the mutation.
func (m *RecvChunkMutation) ChunkOffset() (r int64, exists bool) {
	v := m.chunk_offset
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkOffset returns the old "chunk_offset" field's value of the RecvChunk entity.
// If the RecvChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvChunkMutation) OldChunkOffset(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkOffset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkOffset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkOffset: %w", err)
	}
	return oldValue.ChunkOffset, nil
}

// AddChunkOffset adds i to the "chunk_offset" field.
func (m *RecvChunkMutation) AddChunkOffset(i int64) {
	if m.addchunk_offset != nil {
		*m.addchunk_offset += i
	} else {
		m.addchunk_offset = &i
	}
}

// AddedChunkOffset returns the value that was added to the "chunk_offset" field in this mutation.
func (m *RecvChunkMutation) AddedChunkOffset() (r int64, exists bool) {
	v := m.addchunk_offset
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkOffset resets all changes to the "chunk_offset" field.
func (m *RecvChunkMutation) ResetChunkOffset() {
	m.chunk_offset = nil
	m.addchunk_offset = nil
}

// SetChunkSize sets the "chunk_size" field.
func (m *RecvChunkMutation) SetChunkSize(i int) {
	m.chunk_size = &i
	m.addchunk_size = nil
}

// ChunkSize returns the value of the "chunk_size" field in the mutation.
func (m *RecvChunkMutation) ChunkSize() (r int, exists bool) {
	v := m.chunk_size
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkSize returns the old "chunk_size" field's value of the RecvChunk entity.
// If the RecvChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvChunkMutation) OldChunkSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkSize: %w", err)
	}
	return oldValue.ChunkSize, nil
}

// AddChunkSize adds i to the "chunk_size" field.
func (m *RecvChunkMutation) AddChunkSize(i int) {
	if m.addchunk_size != nil {
		*m.addchunk_size += i
	} else {
		m.addchunk_size = &i
	}
}

// AddedChunkSize returns the value that was added to the "chunk_size" field in this mutation.
func (m *RecvChunkMutation) AddedChunkSize() (r int, exists bool) {
	v := m.addchunk_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkSize resets all changes to the "chunk_size" field.
func (m *RecvChunkMutation) ResetChunkSize() {
	m.chunk_size = nil
	m.addchunk_size = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecvChunkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecvChunkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RecvChunk entity.
// If the RecvChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvChunkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecvChunkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RecvChunkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecvChunkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RecvChunk entity.
// If the RecvChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvChunkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecvChunkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetRecvFileID sets the "recv_file" edge to the RecvFile entity by id.
func (m *RecvChunkMutation) SetRecvFileID(id int) {
	m.recv_file = &id
}

// ClearRecvFile clears the "recv_file" edge to the RecvFile entity.
func (m *RecvChunkMutation) ClearRecvFile() {
	m.clearedrecv_file = true
	m.clearedFields[recvchunk.FieldRecvfileID] = struct{}{}
}

// RecvFileCleared reports if the "recv_file" edge to the RecvFile entity was cleared.
func (m *RecvChunkMutation) RecvFileCleared() bool {
	return m.clearedrecv_file
}

// RecvFileID returns the "recv_file" edge ID in the mutation.
func (m *RecvChunkMutation) RecvFileID() (id int, exists bool) {
	if m.recv_file != nil {
		return *m.recv_file, true
	}
	return
}

// RecvFileIDs returns the "recv_file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecvFileID instead. It exists only for internal usage by the builders.
func (m *RecvChunkMutation) RecvFileIDs() (ids []int) {
	if id := m.recv_file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecvFile resets all changes to the "recv_file" edge.
func (m *RecvChunkMutation) ResetRecvFile() {
	m.recv_file = nil
	m.clearedrecv_file = false
}

// Where appends a list predicates to the RecvChunkMutation builder.
func (m *RecvChunkMutation) Where(ps ...predicate.RecvChunk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecvChunkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecvChunkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecvChunk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecvChunkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecvChunkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecvChunk).
func (m *RecvChunkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecvChunkMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.recv_file != nil {
		fields = append(fields, recvchunk.FieldRecvfileID)
	}
	if m.chunk_index != nil {
		fields = append(fields, recvchunk.FieldChunkIndex)
	}
	if m.chunk_offset != nil {
		fields = append(fields, recvchunk.FieldChunkOffset)
	}
	if m.chunk_size != nil {
		fields = append(fields, recvchunk.FieldChunkSize)
	}
	if m.updated_at != nil {
		fields = append(fields, recvchunk.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, recvchunk.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecvChunkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recvchunk.FieldRecvfileID:
		return m.RecvfileID()
	case recvchunk.FieldChunkIndex:
		return m.ChunkIndex()
	case recvchunk.FieldChunkOffset:
		return m.ChunkOffset()
	case recvchunk.FieldChunkSize:
		return m.ChunkSize()
	case recvchunk.FieldUpdatedAt:
		return m.UpdatedAt()
	case recvchunk.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecvChunkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recvchunk.FieldRecvfileID:
		return m.OldRecvfileID(ctx)
	case recvchunk.FieldChunkIndex:
		return m.OldChunkIndex(ctx)
	case recvchunk.FieldChunkOffset:
		return m.OldChunkOffset(ctx)
	case recvchunk.FieldChunkSize:
		return m.OldChunkSize(ctx)
	case recvchunk.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recvchunk.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RecvChunk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecvChunkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recvchunk.FieldRecvfileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecvfileID(v)
		return nil
	case recvchunk.FieldChunkIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkIndex(v)
		return nil
	case recvchunk.FieldChunkOffset:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkOffset(v)
		return nil
	case recvchunk.FieldChunkSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkSize(v)
		return nil
	case recvchunk.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recvchunk.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RecvChunk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecvChunkMutation) AddedFields() []string {
	var fields []string
	if m.addchunk_index != nil {
		fields = append(fields, recvchunk.FieldChunkIndex)
	}
	if m.addchunk_offset != nil {
		fields = append(fields, recvchunk.FieldChunkOffset)
	}
	if m.addchunk_size != nil {
		fields = append(fields, recvchunk.FieldChunkSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecvChunkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recvchunk.FieldChunkIndex:
		return m.AddedChunkIndex()
	case recvchunk.FieldChunkOffset:
		return m.AddedChunkOffset()
	case recvchunk.FieldChunkSize:
		return m.AddedChunkSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecvChunkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recvchunk.FieldChunkIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkIndex(v)
		return nil
	case recvchunk.FieldChunkOffset:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkOffset(v)
		return nil
	case recvchunk.FieldChunkSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkSize(v)
		return nil
	}
	return fmt.Errorf("unknown RecvChunk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecvChunkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecvChunkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecvChunkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RecvChunk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecvChunkMutation) ResetField(name string) error {
	switch name {
	case recvchunk.FieldRecvfileID:
		m.ResetRecvfileID()
		return nil
	case recvchunk.FieldChunkIndex:
		m.ResetChunkIndex()
		return nil
	case recvchunk.FieldChunkOffset:
		m.ResetChunkOffset()
		return nil
	case recvchunk.FieldChunkSize:
		m.ResetChunkSize()
		return nil
	case recvchunk.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recvchunk.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown RecvChunk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecvChunkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recv_file != nil {
		edges = append(edges, recvchunk.EdgeRecvFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecvChunkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recvchunk.EdgeRecvFile:
		if id := m.recv_file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecvChunkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecvChunkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecvChunkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecv_file {
		edges = append(edges, recvchunk.EdgeRecvFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecvChunkMutation) EdgeCleared(name string) bool {
	switch name {
	case recvchunk.EdgeRecvFile:
		return m.clearedrecv_file
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecvChunkMutation) ClearEdge(name string) error {
	switch name {
	case recvchunk.EdgeRecvFile:
		m.ClearRecvFile()
		return nil
	}
	return fmt.Errorf("unknown RecvChunk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecvChunkMutation) ResetEdge(name string) error {
	switch name {
	case recvchunk.EdgeRecvFile:
		m.ResetRecvFile()
		return nil
	}
	return fmt.Errorf("unknown RecvChunk edge %s", name)
}

// RecvFileMutation represents an operation that mutates the RecvFile nodes in the graph.
type RecvFileMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	task_id             *string
	task_name           *string
	file_path_save      *string
	file_path_origin    *string
	file_id             *string
	file_size           *int64
	addfile_size        *int64
	chunk_num_total     *int
	addchunk_num_total  *int
	chunk_num_recved    *int
	addchunk_num_recved *int
	status              *int
	addstatus           *int
	updated_at          *time.Time
	created_at          *time.Time
	clearedFields       map[string]struct{}
	recv_chunks         map[int]struct{}
	removedrecv_chunks  map[int]struct{}
	clearedrecv_chunks  bool
	done                bool
	oldValue            func(context.Context) (*RecvFile, error)
	predicates          []predicate.RecvFile
}

var _ ent.Mutation = (*RecvFileMutation)(nil)

// recvfileOption allows management of the mutation configuration using functional options.
type recvfileOption func(*RecvFileMutation)

// newRecvFileMutation creates new mutation for the RecvFile entity.
func newRecvFileMutation(c config, op Op, opts ...recvfileOption) *RecvFileMutation {
	m := &RecvFileMutation{
		config:        c,
		op:            op,
		typ:           TypeRecvFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecvFileID sets the ID field of the mutation.
func withRecvFileID(id int) recvfileOption {
	return func(m *RecvFileMutation) {
		var (
			err   error
			once  sync.Once
			value *RecvFile
		)
		m.oldValue = func(ctx context.Context) (*RecvFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecvFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecvFile sets the old RecvFile of the mutation.
func withRecvFile(node *RecvFile) recvfileOption {
	return func(m *RecvFileMutation) {
		m.oldValue = func(context.Context) (*RecvFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecvFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecvFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecvFileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecvFileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecvFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *RecvFileMutation) SetTaskID(s string) {
	m.task_id = &s
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *RecvFileMutation) TaskID() (r string, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the RecvFile entity.
// If the RecvFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvFileMutation) OldTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *RecvFileMutation) ResetTaskID() {
	m.task_id = nil
}

// SetTaskName sets the "task_name" field.
func (m *RecvFileMutation) SetTaskName(s string) {
	m.task_name = &s
}

// TaskName returns the value of the "task_name" field in the mutation.
func (m *RecvFileMutation) TaskName() (r string, exists bool) {
	v := m.task_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskName returns the old "task_name" field's value of the RecvFile entity.
// If the RecvFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvFileMutation) OldTaskName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskName: %w", err)
	}
	return oldValue.TaskName, nil
}

// ResetTaskName resets all changes to the "task_name" field.
func (m *RecvFileMutation) ResetTaskName() {
	m.task_name = nil
}

// SetFilePathSave sets the "file_path_save" field.
func (m *RecvFileMutation) SetFilePathSave(s string) {
	m.file_path_save = &s
}

// FilePathSave returns the value of the "file_path_save" field in the mutation.
func (m *RecvFileMutation) FilePathSave() (r string, exists bool) {
	v := m.file_path_save
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePathSave returns the old "file_path_save" field's value of the RecvFile entity.
// If the RecvFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvFileMutation) OldFilePathSave(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePathSave is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePathSave requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePathSave: %w", err)
	}
	return oldValue.FilePathSave, nil
}

// ResetFilePathSave resets all changes to the "file_path_save" field.
func (m *RecvFileMutation) ResetFilePathSave() {
	m.file_path_save = nil
}

// SetFilePathOrigin sets the "file_path_origin" field.
func (m *RecvFileMutation) SetFilePathOrigin(s string) {
	m.file_path_origin = &s
}

// FilePathOrigin returns the value of the "file_path_origin" field in the mutation.
func (m *RecvFileMutation) FilePathOrigin() (r string, exists bool) {
	v := m.file_path_origin
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePathOrigin returns the old "file_path_origin" field's value of the RecvFile entity.
// If the RecvFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvFileMutation) OldFilePathOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePathOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePathOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePathOrigin: %w", err)
	}
	return oldValue.FilePathOrigin, nil
}

// ResetFilePathOrigin resets all changes to the "file_path_origin" field.
func (m *RecvFileMutation) ResetFilePathOrigin() {
	m.file_path_origin = nil
}

// SetFileID sets the "file_id" field.
func (m *RecvFileMutation) SetFileID(s string) {
	m.file_id = &s
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *RecvFileMutation) FileID() (r string, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the RecvFile entity.
// If the RecvFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvFileMutation) OldFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *RecvFileMutation) ResetFileID() {
	m.file_id = nil
}

// SetFileSize sets the "file_size" field.
func (m *RecvFileMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *RecvFileMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the RecvFile entity.
// If the RecvFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvFileMutation) OldFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *RecvFileMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *RecvFileMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *RecvFileMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
}

// SetChunkNumTotal sets the "chunk_num_total" field.
func (m *RecvFileMutation) SetChunkNumTotal(i int) {
	m.chunk_num_total = &i
	m.addchunk_num_total = nil
}

// ChunkNumTotal returns the value of the "chunk_num_total" field in the mutation.
func (m *RecvFileMutation) ChunkNumTotal() (r int, exists bool) {
	v := m.chunk_num_total
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkNumTotal returns the old "chunk_num_total" field's value of the RecvFile entity.
// If the RecvFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvFileMutation) OldChunkNumTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkNumTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkNumTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkNumTotal: %w", err)
	}
	return oldValue.ChunkNumTotal, nil
}

// AddChunkNumTotal adds i to the "chunk_num_total" field.
func (m *RecvFileMutation) AddChunkNumTotal(i int) {
	if m.addchunk_num_total != nil {
		*m.addchunk_num_total += i
	} else {
		m.addchunk_num_total = &i
	}
}

// AddedChunkNumTotal returns the value that was added to the "chunk_num_total" field in this mutation.
func (m *RecvFileMutation) AddedChunkNumTotal() (r int, exists bool) {
	v := m.addchunk_num_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkNumTotal resets all changes to the "chunk_num_total" field.
func (m *RecvFileMutation) ResetChunkNumTotal() {
	m.chunk_num_total = nil
	m.addchunk_num_total = nil
}

// SetChunkNumRecved sets the "chunk_num_recved" field.
func (m *RecvFileMutation) SetChunkNumRecved(i int) {
	m.chunk_num_recved = &i
	m.addchunk_num_recved = nil
}

// ChunkNumRecved returns the value of the "chunk_num_recved" field in the mutation.
func (m *RecvFileMutation) ChunkNumRecved() (r int, exists bool) {
	v := m.chunk_num_recved
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkNumRecved returns the old "chunk_num_recved" field's value of the RecvFile entity.
// If the RecvFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvFileMutation) OldChunkNumRecved(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkNumRecved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkNumRecved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkNumRecved: %w", err)
	}
	return oldValue.ChunkNumRecved, nil
}

// AddChunkNumRecved adds i to the "chunk_num_recved" field.
func (m *RecvFileMutation) AddChunkNumRecved(i int) {
	if m.addchunk_num_recved != nil {
		*m.addchunk_num_recved += i
	} else {
		m.addchunk_num_recved = &i
	}
}

// AddedChunkNumRecved returns the value that was added to the "chunk_num_recved" field in this mutation.
func (m *RecvFileMutation) AddedChunkNumRecved() (r int, exists bool) {
	v := m.addchunk_num_recved
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkNumRecved resets all changes to the "chunk_num_recved" field.
func (m *RecvFileMutation) ResetChunkNumRecved() {
	m.chunk_num_recved = nil
	m.addchunk_num_recved = nil
}

// SetStatus sets the "status" field.
func (m *RecvFileMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RecvFileMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RecvFile entity.
// If the RecvFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvFileMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RecvFileMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RecvFileMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *RecvFileMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecvFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecvFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RecvFile entity.
// If the RecvFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecvFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RecvFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecvFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RecvFile entity.
// If the RecvFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecvFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecvFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddRecvChunkIDs adds the "recv_chunks" edge to the RecvChunk entity by ids.
func (m *RecvFileMutation) AddRecvChunkIDs(ids ...int) {
	if m.recv_chunks == nil {
		m.recv_chunks = make(map[int]struct{})
	}
	for i := range ids {
		m.recv_chunks[ids[i]] = struct{}{}
	}
}

// ClearRecvChunks clears the "recv_chunks" edge to the RecvChunk entity.
func (m *RecvFileMutation) ClearRecvChunks() {
	m.clearedrecv_chunks = true
}

// RecvChunksCleared reports if the "recv_chunks" edge to the RecvChunk entity was cleared.
func (m *RecvFileMutation) RecvChunksCleared() bool {
	return m.clearedrecv_chunks
}

// RemoveRecvChunkIDs removes the "recv_chunks" edge to the RecvChunk entity by IDs.
func (m *RecvFileMutation) RemoveRecvChunkIDs(ids ...int) {
	if m.removedrecv_chunks == nil {
		m.removedrecv_chunks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recv_chunks, ids[i])
		m.removedrecv_chunks[ids[i]] = struct{}{}
	}
}

// RemovedRecvChunks returns the removed IDs of the "recv_chunks" edge to the RecvChunk entity.
func (m *RecvFileMutation) RemovedRecvChunksIDs() (ids []int) {
	for id := range m.removedrecv_chunks {
		ids = append(ids, id)
	}
	return
}

// RecvChunksIDs returns the "recv_chunks" edge IDs in the mutation.
func (m *RecvFileMutation) RecvChunksIDs() (ids []int) {
	for id := range m.recv_chunks {
		ids = append(ids, id)
	}
	return
}

// ResetRecvChunks resets all changes to the "recv_chunks" edge.
func (m *RecvFileMutation) ResetRecvChunks() {
	m.recv_chunks = nil
	m.clearedrecv_chunks = false
	m.removedrecv_chunks = nil
}

// Where appends a list predicates to the RecvFileMutation builder.
func (m *RecvFileMutation) Where(ps ...predicate.RecvFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecvFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecvFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecvFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecvFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecvFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecvFile).
func (m *RecvFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecvFileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.task_id != nil {
		fields = append(fields, recvfile.FieldTaskID)
	}
	if m.task_name != nil {
		fields = append(fields, recvfile.FieldTaskName)
	}
	if m.file_path_save != nil {
		fields = append(fields, recvfile.FieldFilePathSave)
	}
	if m.file_path_origin != nil {
		fields = append(fields, recvfile.FieldFilePathOrigin)
	}
	if m.file_id != nil {
		fields = append(fields, recvfile.FieldFileID)
	}
	if m.file_size != nil {
		fields = append(fields, recvfile.FieldFileSize)
	}
	if m.chunk_num_total != nil {
		fields = append(fields, recvfile.FieldChunkNumTotal)
	}
	if m.chunk_num_recved != nil {
		fields = append(fields, recvfile.FieldChunkNumRecved)
	}
	if m.status != nil {
		fields = append(fields, recvfile.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, recvfile.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, recvfile.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecvFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recvfile.FieldTaskID:
		return m.TaskID()
	case recvfile.FieldTaskName:
		return m.TaskName()
	case recvfile.FieldFilePathSave:
		return m.FilePathSave()
	case recvfile.FieldFilePathOrigin:
		return m.FilePathOrigin()
	case recvfile.FieldFileID:
		return m.FileID()
	case recvfile.FieldFileSize:
		return m.FileSize()
	case recvfile.FieldChunkNumTotal:
		return m.ChunkNumTotal()
	case recvfile.FieldChunkNumRecved:
		return m.ChunkNumRecved()
	case recvfile.FieldStatus:
		return m.Status()
	case recvfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case recvfile.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecvFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recvfile.FieldTaskID:
		return m.OldTaskID(ctx)
	case recvfile.FieldTaskName:
		return m.OldTaskName(ctx)
	case recvfile.FieldFilePathSave:
		return m.OldFilePathSave(ctx)
	case recvfile.FieldFilePathOrigin:
		return m.OldFilePathOrigin(ctx)
	case recvfile.FieldFileID:
		return m.OldFileID(ctx)
	case recvfile.FieldFileSize:
		return m.OldFileSize(ctx)
	case recvfile.FieldChunkNumTotal:
		return m.OldChunkNumTotal(ctx)
	case recvfile.FieldChunkNumRecved:
		return m.OldChunkNumRecved(ctx)
	case recvfile.FieldStatus:
		return m.OldStatus(ctx)
	case recvfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recvfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RecvFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecvFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recvfile.FieldTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case recvfile.FieldTaskName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskName(v)
		return nil
	case recvfile.FieldFilePathSave:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePathSave(v)
		return nil
	case recvfile.FieldFilePathOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePathOrigin(v)
		return nil
	case recvfile.FieldFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case recvfile.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case recvfile.FieldChunkNumTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkNumTotal(v)
		return nil
	case recvfile.FieldChunkNumRecved:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkNumRecved(v)
		return nil
	case recvfile.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case recvfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recvfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RecvFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecvFileMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, recvfile.FieldFileSize)
	}
	if m.addchunk_num_total != nil {
		fields = append(fields, recvfile.FieldChunkNumTotal)
	}
	if m.addchunk_num_recved != nil {
		fields = append(fields, recvfile.FieldChunkNumRecved)
	}
	if m.addstatus != nil {
		fields = append(fields, recvfile.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecvFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recvfile.FieldFileSize:
		return m.AddedFileSize()
	case recvfile.FieldChunkNumTotal:
		return m.AddedChunkNumTotal()
	case recvfile.FieldChunkNumRecved:
		return m.AddedChunkNumRecved()
	case recvfile.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecvFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recvfile.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	case recvfile.FieldChunkNumTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkNumTotal(v)
		return nil
	case recvfile.FieldChunkNumRecved:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkNumRecved(v)
		return nil
	case recvfile.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown RecvFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecvFileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecvFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecvFileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RecvFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecvFileMutation) ResetField(name string) error {
	switch name {
	case recvfile.FieldTaskID:
		m.ResetTaskID()
		return nil
	case recvfile.FieldTaskName:
		m.ResetTaskName()
		return nil
	case recvfile.FieldFilePathSave:
		m.ResetFilePathSave()
		return nil
	case recvfile.FieldFilePathOrigin:
		m.ResetFilePathOrigin()
		return nil
	case recvfile.FieldFileID:
		m.ResetFileID()
		return nil
	case recvfile.FieldFileSize:
		m.ResetFileSize()
		return nil
	case recvfile.FieldChunkNumTotal:
		m.ResetChunkNumTotal()
		return nil
	case recvfile.FieldChunkNumRecved:
		m.ResetChunkNumRecved()
		return nil
	case recvfile.FieldStatus:
		m.ResetStatus()
		return nil
	case recvfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recvfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown RecvFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecvFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recv_chunks != nil {
		edges = append(edges, recvfile.EdgeRecvChunks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecvFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recvfile.EdgeRecvChunks:
		ids := make([]ent.Value, 0, len(m.recv_chunks))
		for id := range m.recv_chunks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecvFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecv_chunks != nil {
		edges = append(edges, recvfile.EdgeRecvChunks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecvFileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case recvfile.EdgeRecvChunks:
		ids := make([]ent.Value, 0, len(m.removedrecv_chunks))
		for id := range m.removedrecv_chunks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecvFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecv_chunks {
		edges = append(edges, recvfile.EdgeRecvChunks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecvFileMutation) EdgeCleared(name string) bool {
	switch name {
	case recvfile.EdgeRecvChunks:
		return m.clearedrecv_chunks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecvFileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RecvFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecvFileMutation) ResetEdge(name string) error {
	switch name {
	case recvfile.EdgeRecvChunks:
		m.ResetRecvChunks()
		return nil
	}
	return fmt.Errorf("unknown RecvFile edge %s", name)
}

// SendChunkMutation represents an operation that mutates the SendChunk nodes in the graph.
type SendChunkMutation struct {
	config
	op               Op
	typ              string
	id               *int
	chunk_index      *int
	addchunk_index   *int
	chunk_offset     *int64
	addchunk_offset  *int64
	chunk_size       *int
	addchunk_size    *int
	updated_at       *time.Time
	created_at       *time.Time
	clearedFields    map[string]struct{}
	send_file        *int
	clearedsend_file bool
	done             bool
	oldValue         func(context.Context) (*SendChunk, error)
	predicates       []predicate.SendChunk
}

var _ ent.Mutation = (*SendChunkMutation)(nil)

// sendchunkOption allows management of the mutation configuration using functional options.
type sendchunkOption func(*SendChunkMutation)

// newSendChunkMutation creates new mutation for the SendChunk entity.
func newSendChunkMutation(c config, op Op, opts ...sendchunkOption) *SendChunkMutation {
	m := &SendChunkMutation{
		config:        c,
		op:            op,
		typ:           TypeSendChunk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSendChunkID sets the ID field of the mutation.
func withSendChunkID(id int) sendchunkOption {
	return func(m *SendChunkMutation) {
		var (
			err   error
			once  sync.Once
			value *SendChunk
		)
		m.oldValue = func(ctx context.Context) (*SendChunk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SendChunk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSendChunk sets the old SendChunk of the mutation.
func withSendChunk(node *SendChunk) sendchunkOption {
	return func(m *SendChunkMutation) {
		m.oldValue = func(context.Context) (*SendChunk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SendChunkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SendChunkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SendChunkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SendChunkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SendChunk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSendfileID sets the "sendfile_id" field.
func (m *SendChunkMutation) SetSendfileID(i int) {
	m.send_file = &i
}

// SendfileID returns the value of the "sendfile_id" field in the mutation.
func (m *SendChunkMutation) SendfileID() (r int, exists bool) {
	v := m.send_file
	if v == nil {
		return
	}
	return *v, true
}

// OldSendfileID returns the old "sendfile_id" field's value of the SendChunk entity.
// If the SendChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendChunkMutation) OldSendfileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendfileID: %w", err)
	}
	return oldValue.SendfileID, nil
}

// ResetSendfileID resets all changes to the "sendfile_id" field.
func (m *SendChunkMutation) ResetSendfileID() {
	m.send_file = nil
}

// SetChunkIndex sets the "chunk_index" field.
func (m *SendChunkMutation) SetChunkIndex(i int) {
	m.chunk_index = &i
	m.addchunk_index = nil
}

// ChunkIndex returns the value of the "chunk_index" field in the mutation.
func (m *SendChunkMutation) ChunkIndex() (r int, exists bool) {
	v := m.chunk_index
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkIndex returns the old "chunk_index" field's value of the SendChunk entity.
// If the SendChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendChunkMutation) OldChunkIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkIndex: %w", err)
	}
	return oldValue.ChunkIndex, nil
}

// AddChunkIndex adds i to the "chunk_index" field.
func (m *SendChunkMutation) AddChunkIndex(i int) {
	if m.addchunk_index != nil {
		*m.addchunk_index += i
	} else {
		m.addchunk_index = &i
	}
}

// AddedChunkIndex returns the value that was added to the "chunk_index" field in this mutation.
func (m *SendChunkMutation) AddedChunkIndex() (r int, exists bool) {
	v := m.addchunk_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkIndex resets all changes to the "chunk_index" field.
func (m *SendChunkMutation) ResetChunkIndex() {
	m.chunk_index = nil
	m.addchunk_index = nil
}

// SetChunkOffset sets the "chunk_offset" field.
func (m *SendChunkMutation) SetChunkOffset(i int64) {
	m.chunk_offset = &i
	m.addchunk_offset = nil
}

// ChunkOffset returns the value of the "chunk_offset" field in the mutation.
func (m *SendChunkMutation) ChunkOffset() (r int64, exists bool) {
	v := m.chunk_offset
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkOffset returns the old "chunk_offset" field's value of the SendChunk entity.
// If the SendChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendChunkMutation) OldChunkOffset(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkOffset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkOffset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkOffset: %w", err)
	}
	return oldValue.ChunkOffset, nil
}

// AddChunkOffset adds i to the "chunk_offset" field.
func (m *SendChunkMutation) AddChunkOffset(i int64) {
	if m.addchunk_offset != nil {
		*m.addchunk_offset += i
	} else {
		m.addchunk_offset = &i
	}
}

// AddedChunkOffset returns the value that was added to the "chunk_offset" field in this mutation.
func (m *SendChunkMutation) AddedChunkOffset() (r int64, exists bool) {
	v := m.addchunk_offset
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkOffset resets all changes to the "chunk_offset" field.
func (m *SendChunkMutation) ResetChunkOffset() {
	m.chunk_offset = nil
	m.addchunk_offset = nil
}

// SetChunkSize sets the "chunk_size" field.
func (m *SendChunkMutation) SetChunkSize(i int) {
	m.chunk_size = &i
	m.addchunk_size = nil
}

// ChunkSize returns the value of the "chunk_size" field in the mutation.
func (m *SendChunkMutation) ChunkSize() (r int, exists bool) {
	v := m.chunk_size
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkSize returns the old "chunk_size" field's value of the SendChunk entity.
// If the SendChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendChunkMutation) OldChunkSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkSize: %w", err)
	}
	return oldValue.ChunkSize, nil
}

// AddChunkSize adds i to the "chunk_size" field.
func (m *SendChunkMutation) AddChunkSize(i int) {
	if m.addchunk_size != nil {
		*m.addchunk_size += i
	} else {
		m.addchunk_size = &i
	}
}

// AddedChunkSize returns the value that was added to the "chunk_size" field in this mutation.
func (m *SendChunkMutation) AddedChunkSize() (r int, exists bool) {
	v := m.addchunk_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkSize resets all changes to the "chunk_size" field.
func (m *SendChunkMutation) ResetChunkSize() {
	m.chunk_size = nil
	m.addchunk_size = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SendChunkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SendChunkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SendChunk entity.
// If the SendChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendChunkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SendChunkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SendChunkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SendChunkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SendChunk entity.
// If the SendChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendChunkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SendChunkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetSendFileID sets the "send_file" edge to the SendFile entity by id.
func (m *SendChunkMutation) SetSendFileID(id int) {
	m.send_file = &id
}

// ClearSendFile clears the "send_file" edge to the SendFile entity.
func (m *SendChunkMutation) ClearSendFile() {
	m.clearedsend_file = true
	m.clearedFields[sendchunk.FieldSendfileID] = struct{}{}
}

// SendFileCleared reports if the "send_file" edge to the SendFile entity was cleared.
func (m *SendChunkMutation) SendFileCleared() bool {
	return m.clearedsend_file
}

// SendFileID returns the "send_file" edge ID in the mutation.
func (m *SendChunkMutation) SendFileID() (id int, exists bool) {
	if m.send_file != nil {
		return *m.send_file, true
	}
	return
}

// SendFileIDs returns the "send_file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SendFileID instead. It exists only for internal usage by the builders.
func (m *SendChunkMutation) SendFileIDs() (ids []int) {
	if id := m.send_file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSendFile resets all changes to the "send_file" edge.
func (m *SendChunkMutation) ResetSendFile() {
	m.send_file = nil
	m.clearedsend_file = false
}

// Where appends a list predicates to the SendChunkMutation builder.
func (m *SendChunkMutation) Where(ps ...predicate.SendChunk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SendChunkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SendChunkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SendChunk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SendChunkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SendChunkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SendChunk).
func (m *SendChunkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SendChunkMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.send_file != nil {
		fields = append(fields, sendchunk.FieldSendfileID)
	}
	if m.chunk_index != nil {
		fields = append(fields, sendchunk.FieldChunkIndex)
	}
	if m.chunk_offset != nil {
		fields = append(fields, sendchunk.FieldChunkOffset)
	}
	if m.chunk_size != nil {
		fields = append(fields, sendchunk.FieldChunkSize)
	}
	if m.updated_at != nil {
		fields = append(fields, sendchunk.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, sendchunk.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SendChunkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sendchunk.FieldSendfileID:
		return m.SendfileID()
	case sendchunk.FieldChunkIndex:
		return m.ChunkIndex()
	case sendchunk.FieldChunkOffset:
		return m.ChunkOffset()
	case sendchunk.FieldChunkSize:
		return m.ChunkSize()
	case sendchunk.FieldUpdatedAt:
		return m.UpdatedAt()
	case sendchunk.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SendChunkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sendchunk.FieldSendfileID:
		return m.OldSendfileID(ctx)
	case sendchunk.FieldChunkIndex:
		return m.OldChunkIndex(ctx)
	case sendchunk.FieldChunkOffset:
		return m.OldChunkOffset(ctx)
	case sendchunk.FieldChunkSize:
		return m.OldChunkSize(ctx)
	case sendchunk.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sendchunk.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SendChunk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SendChunkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sendchunk.FieldSendfileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendfileID(v)
		return nil
	case sendchunk.FieldChunkIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkIndex(v)
		return nil
	case sendchunk.FieldChunkOffset:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkOffset(v)
		return nil
	case sendchunk.FieldChunkSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkSize(v)
		return nil
	case sendchunk.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sendchunk.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SendChunk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SendChunkMutation) AddedFields() []string {
	var fields []string
	if m.addchunk_index != nil {
		fields = append(fields, sendchunk.FieldChunkIndex)
	}
	if m.addchunk_offset != nil {
		fields = append(fields, sendchunk.FieldChunkOffset)
	}
	if m.addchunk_size != nil {
		fields = append(fields, sendchunk.FieldChunkSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SendChunkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sendchunk.FieldChunkIndex:
		return m.AddedChunkIndex()
	case sendchunk.FieldChunkOffset:
		return m.AddedChunkOffset()
	case sendchunk.FieldChunkSize:
		return m.AddedChunkSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SendChunkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sendchunk.FieldChunkIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkIndex(v)
		return nil
	case sendchunk.FieldChunkOffset:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkOffset(v)
		return nil
	case sendchunk.FieldChunkSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkSize(v)
		return nil
	}
	return fmt.Errorf("unknown SendChunk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SendChunkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SendChunkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SendChunkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SendChunk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SendChunkMutation) ResetField(name string) error {
	switch name {
	case sendchunk.FieldSendfileID:
		m.ResetSendfileID()
		return nil
	case sendchunk.FieldChunkIndex:
		m.ResetChunkIndex()
		return nil
	case sendchunk.FieldChunkOffset:
		m.ResetChunkOffset()
		return nil
	case sendchunk.FieldChunkSize:
		m.ResetChunkSize()
		return nil
	case sendchunk.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sendchunk.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SendChunk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SendChunkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.send_file != nil {
		edges = append(edges, sendchunk.EdgeSendFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SendChunkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sendchunk.EdgeSendFile:
		if id := m.send_file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SendChunkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SendChunkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SendChunkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsend_file {
		edges = append(edges, sendchunk.EdgeSendFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SendChunkMutation) EdgeCleared(name string) bool {
	switch name {
	case sendchunk.EdgeSendFile:
		return m.clearedsend_file
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SendChunkMutation) ClearEdge(name string) error {
	switch name {
	case sendchunk.EdgeSendFile:
		m.ClearSendFile()
		return nil
	}
	return fmt.Errorf("unknown SendChunk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SendChunkMutation) ResetEdge(name string) error {
	switch name {
	case sendchunk.EdgeSendFile:
		m.ResetSendFile()
		return nil
	}
	return fmt.Errorf("unknown SendChunk edge %s", name)
}

// SendFileMutation represents an operation that mutates the SendFile nodes in the graph.
type SendFileMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	task_id             *string
	task_name           *string
	file_path           *string
	file_id             *string
	file_size           *int64
	addfile_size        *int64
	chunk_num_total     *int
	addchunk_num_total  *int
	chunk_num_sended    *int
	addchunk_num_sended *int
	status              *int
	addstatus           *int
	elapsed             *string
	speed               *string
	updated_at          *time.Time
	created_at          *time.Time
	clearedFields       map[string]struct{}
	send_chunks         map[int]struct{}
	removedsend_chunks  map[int]struct{}
	clearedsend_chunks  bool
	done                bool
	oldValue            func(context.Context) (*SendFile, error)
	predicates          []predicate.SendFile
}

var _ ent.Mutation = (*SendFileMutation)(nil)

// sendfileOption allows management of the mutation configuration using functional options.
type sendfileOption func(*SendFileMutation)

// newSendFileMutation creates new mutation for the SendFile entity.
func newSendFileMutation(c config, op Op, opts ...sendfileOption) *SendFileMutation {
	m := &SendFileMutation{
		config:        c,
		op:            op,
		typ:           TypeSendFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSendFileID sets the ID field of the mutation.
func withSendFileID(id int) sendfileOption {
	return func(m *SendFileMutation) {
		var (
			err   error
			once  sync.Once
			value *SendFile
		)
		m.oldValue = func(ctx context.Context) (*SendFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SendFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSendFile sets the old SendFile of the mutation.
func withSendFile(node *SendFile) sendfileOption {
	return func(m *SendFileMutation) {
		m.oldValue = func(context.Context) (*SendFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SendFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SendFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SendFileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SendFileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SendFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *SendFileMutation) SetTaskID(s string) {
	m.task_id = &s
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *SendFileMutation) TaskID() (r string, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *SendFileMutation) ResetTaskID() {
	m.task_id = nil
}

// SetTaskName sets the "task_name" field.
func (m *SendFileMutation) SetTaskName(s string) {
	m.task_name = &s
}

// TaskName returns the value of the "task_name" field in the mutation.
func (m *SendFileMutation) TaskName() (r string, exists bool) {
	v := m.task_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskName returns the old "task_name" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldTaskName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskName: %w", err)
	}
	return oldValue.TaskName, nil
}

// ResetTaskName resets all changes to the "task_name" field.
func (m *SendFileMutation) ResetTaskName() {
	m.task_name = nil
}

// SetFilePath sets the "file_path" field.
func (m *SendFileMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *SendFileMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *SendFileMutation) ResetFilePath() {
	m.file_path = nil
}

// SetFileID sets the "file_id" field.
func (m *SendFileMutation) SetFileID(s string) {
	m.file_id = &s
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *SendFileMutation) FileID() (r string, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *SendFileMutation) ResetFileID() {
	m.file_id = nil
}

// SetFileSize sets the "file_size" field.
func (m *SendFileMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *SendFileMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *SendFileMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *SendFileMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *SendFileMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
}

// SetChunkNumTotal sets the "chunk_num_total" field.
func (m *SendFileMutation) SetChunkNumTotal(i int) {
	m.chunk_num_total = &i
	m.addchunk_num_total = nil
}

// ChunkNumTotal returns the value of the "chunk_num_total" field in the mutation.
func (m *SendFileMutation) ChunkNumTotal() (r int, exists bool) {
	v := m.chunk_num_total
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkNumTotal returns the old "chunk_num_total" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldChunkNumTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkNumTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkNumTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkNumTotal: %w", err)
	}
	return oldValue.ChunkNumTotal, nil
}

// AddChunkNumTotal adds i to the "chunk_num_total" field.
func (m *SendFileMutation) AddChunkNumTotal(i int) {
	if m.addchunk_num_total != nil {
		*m.addchunk_num_total += i
	} else {
		m.addchunk_num_total = &i
	}
}

// AddedChunkNumTotal returns the value that was added to the "chunk_num_total" field in this mutation.
func (m *SendFileMutation) AddedChunkNumTotal() (r int, exists bool) {
	v := m.addchunk_num_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkNumTotal resets all changes to the "chunk_num_total" field.
func (m *SendFileMutation) ResetChunkNumTotal() {
	m.chunk_num_total = nil
	m.addchunk_num_total = nil
}

// SetChunkNumSended sets the "chunk_num_sended" field.
func (m *SendFileMutation) SetChunkNumSended(i int) {
	m.chunk_num_sended = &i
	m.addchunk_num_sended = nil
}

// ChunkNumSended returns the value of the "chunk_num_sended" field in the mutation.
func (m *SendFileMutation) ChunkNumSended() (r int, exists bool) {
	v := m.chunk_num_sended
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkNumSended returns the old "chunk_num_sended" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldChunkNumSended(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkNumSended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkNumSended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkNumSended: %w", err)
	}
	return oldValue.ChunkNumSended, nil
}

// AddChunkNumSended adds i to the "chunk_num_sended" field.
func (m *SendFileMutation) AddChunkNumSended(i int) {
	if m.addchunk_num_sended != nil {
		*m.addchunk_num_sended += i
	} else {
		m.addchunk_num_sended = &i
	}
}

// AddedChunkNumSended returns the value that was added to the "chunk_num_sended" field in this mutation.
func (m *SendFileMutation) AddedChunkNumSended() (r int, exists bool) {
	v := m.addchunk_num_sended
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkNumSended resets all changes to the "chunk_num_sended" field.
func (m *SendFileMutation) ResetChunkNumSended() {
	m.chunk_num_sended = nil
	m.addchunk_num_sended = nil
}

// SetStatus sets the "status" field.
func (m *SendFileMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SendFileMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SendFileMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SendFileMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SendFileMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetElapsed sets the "elapsed" field.
func (m *SendFileMutation) SetElapsed(s string) {
	m.elapsed = &s
}

// Elapsed returns the value of the "elapsed" field in the mutation.
func (m *SendFileMutation) Elapsed() (r string, exists bool) {
	v := m.elapsed
	if v == nil {
		return
	}
	return *v, true
}

// OldElapsed returns the old "elapsed" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldElapsed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElapsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElapsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElapsed: %w", err)
	}
	return oldValue.Elapsed, nil
}

// ResetElapsed resets all changes to the "elapsed" field.
func (m *SendFileMutation) ResetElapsed() {
	m.elapsed = nil
}

// SetSpeed sets the "speed" field.
func (m *SendFileMutation) SetSpeed(s string) {
	m.speed = &s
}

// Speed returns the value of the "speed" field in the mutation.
func (m *SendFileMutation) Speed() (r string, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// ResetSpeed resets all changes to the "speed" field.
func (m *SendFileMutation) ResetSpeed() {
	m.speed = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SendFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SendFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SendFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SendFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SendFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SendFile entity.
// If the SendFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SendFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SendFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddSendChunkIDs adds the "send_chunks" edge to the SendChunk entity by ids.
func (m *SendFileMutation) AddSendChunkIDs(ids ...int) {
	if m.send_chunks == nil {
		m.send_chunks = make(map[int]struct{})
	}
	for i := range ids {
		m.send_chunks[ids[i]] = struct{}{}
	}
}

// ClearSendChunks clears the "send_chunks" edge to the SendChunk entity.
func (m *SendFileMutation) ClearSendChunks() {
	m.clearedsend_chunks = true
}

// SendChunksCleared reports if the "send_chunks" edge to the SendChunk entity was cleared.
func (m *SendFileMutation) SendChunksCleared() bool {
	return m.clearedsend_chunks
}

// RemoveSendChunkIDs removes the "send_chunks" edge to the SendChunk entity by IDs.
func (m *SendFileMutation) RemoveSendChunkIDs(ids ...int) {
	if m.removedsend_chunks == nil {
		m.removedsend_chunks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.send_chunks, ids[i])
		m.removedsend_chunks[ids[i]] = struct{}{}
	}
}

// RemovedSendChunks returns the removed IDs of the "send_chunks" edge to the SendChunk entity.
func (m *SendFileMutation) RemovedSendChunksIDs() (ids []int) {
	for id := range m.removedsend_chunks {
		ids = append(ids, id)
	}
	return
}

// SendChunksIDs returns the "send_chunks" edge IDs in the mutation.
func (m *SendFileMutation) SendChunksIDs() (ids []int) {
	for id := range m.send_chunks {
		ids = append(ids, id)
	}
	return
}

// ResetSendChunks resets all changes to the "send_chunks" edge.
func (m *SendFileMutation) ResetSendChunks() {
	m.send_chunks = nil
	m.clearedsend_chunks = false
	m.removedsend_chunks = nil
}

// Where appends a list predicates to the SendFileMutation builder.
func (m *SendFileMutation) Where(ps ...predicate.SendFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SendFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SendFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SendFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SendFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SendFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SendFile).
func (m *SendFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SendFileMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.task_id != nil {
		fields = append(fields, sendfile.FieldTaskID)
	}
	if m.task_name != nil {
		fields = append(fields, sendfile.FieldTaskName)
	}
	if m.file_path != nil {
		fields = append(fields, sendfile.FieldFilePath)
	}
	if m.file_id != nil {
		fields = append(fields, sendfile.FieldFileID)
	}
	if m.file_size != nil {
		fields = append(fields, sendfile.FieldFileSize)
	}
	if m.chunk_num_total != nil {
		fields = append(fields, sendfile.FieldChunkNumTotal)
	}
	if m.chunk_num_sended != nil {
		fields = append(fields, sendfile.FieldChunkNumSended)
	}
	if m.status != nil {
		fields = append(fields, sendfile.FieldStatus)
	}
	if m.elapsed != nil {
		fields = append(fields, sendfile.FieldElapsed)
	}
	if m.speed != nil {
		fields = append(fields, sendfile.FieldSpeed)
	}
	if m.updated_at != nil {
		fields = append(fields, sendfile.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, sendfile.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SendFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sendfile.FieldTaskID:
		return m.TaskID()
	case sendfile.FieldTaskName:
		return m.TaskName()
	case sendfile.FieldFilePath:
		return m.FilePath()
	case sendfile.FieldFileID:
		return m.FileID()
	case sendfile.FieldFileSize:
		return m.FileSize()
	case sendfile.FieldChunkNumTotal:
		return m.ChunkNumTotal()
	case sendfile.FieldChunkNumSended:
		return m.ChunkNumSended()
	case sendfile.FieldStatus:
		return m.Status()
	case sendfile.FieldElapsed:
		return m.Elapsed()
	case sendfile.FieldSpeed:
		return m.Speed()
	case sendfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case sendfile.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SendFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sendfile.FieldTaskID:
		return m.OldTaskID(ctx)
	case sendfile.FieldTaskName:
		return m.OldTaskName(ctx)
	case sendfile.FieldFilePath:
		return m.OldFilePath(ctx)
	case sendfile.FieldFileID:
		return m.OldFileID(ctx)
	case sendfile.FieldFileSize:
		return m.OldFileSize(ctx)
	case sendfile.FieldChunkNumTotal:
		return m.OldChunkNumTotal(ctx)
	case sendfile.FieldChunkNumSended:
		return m.OldChunkNumSended(ctx)
	case sendfile.FieldStatus:
		return m.OldStatus(ctx)
	case sendfile.FieldElapsed:
		return m.OldElapsed(ctx)
	case sendfile.FieldSpeed:
		return m.OldSpeed(ctx)
	case sendfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sendfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SendFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SendFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sendfile.FieldTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case sendfile.FieldTaskName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskName(v)
		return nil
	case sendfile.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case sendfile.FieldFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case sendfile.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case sendfile.FieldChunkNumTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkNumTotal(v)
		return nil
	case sendfile.FieldChunkNumSended:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkNumSended(v)
		return nil
	case sendfile.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sendfile.FieldElapsed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElapsed(v)
		return nil
	case sendfile.FieldSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	case sendfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sendfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SendFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SendFileMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, sendfile.FieldFileSize)
	}
	if m.addchunk_num_total != nil {
		fields = append(fields, sendfile.FieldChunkNumTotal)
	}
	if m.addchunk_num_sended != nil {
		fields = append(fields, sendfile.FieldChunkNumSended)
	}
	if m.addstatus != nil {
		fields = append(fields, sendfile.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SendFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sendfile.FieldFileSize:
		return m.AddedFileSize()
	case sendfile.FieldChunkNumTotal:
		return m.AddedChunkNumTotal()
	case sendfile.FieldChunkNumSended:
		return m.AddedChunkNumSended()
	case sendfile.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SendFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sendfile.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	case sendfile.FieldChunkNumTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkNumTotal(v)
		return nil
	case sendfile.FieldChunkNumSended:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkNumSended(v)
		return nil
	case sendfile.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown SendFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SendFileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SendFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SendFileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SendFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SendFileMutation) ResetField(name string) error {
	switch name {
	case sendfile.FieldTaskID:
		m.ResetTaskID()
		return nil
	case sendfile.FieldTaskName:
		m.ResetTaskName()
		return nil
	case sendfile.FieldFilePath:
		m.ResetFilePath()
		return nil
	case sendfile.FieldFileID:
		m.ResetFileID()
		return nil
	case sendfile.FieldFileSize:
		m.ResetFileSize()
		return nil
	case sendfile.FieldChunkNumTotal:
		m.ResetChunkNumTotal()
		return nil
	case sendfile.FieldChunkNumSended:
		m.ResetChunkNumSended()
		return nil
	case sendfile.FieldStatus:
		m.ResetStatus()
		return nil
	case sendfile.FieldElapsed:
		m.ResetElapsed()
		return nil
	case sendfile.FieldSpeed:
		m.ResetSpeed()
		return nil
	case sendfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sendfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SendFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SendFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.send_chunks != nil {
		edges = append(edges, sendfile.EdgeSendChunks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SendFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sendfile.EdgeSendChunks:
		ids := make([]ent.Value, 0, len(m.send_chunks))
		for id := range m.send_chunks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SendFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsend_chunks != nil {
		edges = append(edges, sendfile.EdgeSendChunks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SendFileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sendfile.EdgeSendChunks:
		ids := make([]ent.Value, 0, len(m.removedsend_chunks))
		for id := range m.removedsend_chunks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SendFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsend_chunks {
		edges = append(edges, sendfile.EdgeSendChunks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SendFileMutation) EdgeCleared(name string) bool {
	switch name {
	case sendfile.EdgeSendChunks:
		return m.clearedsend_chunks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SendFileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SendFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SendFileMutation) ResetEdge(name string) error {
	switch name {
	case sendfile.EdgeSendChunks:
		m.ResetSendChunks()
		return nil
	}
	return fmt.Errorf("unknown SendFile edge %s", name)
}
