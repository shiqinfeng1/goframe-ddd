// Code generated by MockGen. DO NOT EDIT.
// Source: ./interfaces.go
//
// Generated by this command:
//
//	mockgen -destination=mock_client.go -package=nats -source=./interfaces.go ConnIntf,ConnectionManagerIntf,SubscriptionManagerIntf
//

// Package nats is a generated GoMock package.
package nats

import (
	context "context"
	reflect "reflect"

	nats "github.com/nats-io/nats.go"
	jetstream "github.com/nats-io/nats.go/jetstream"
	health "github.com/shiqinfeng1/goframe-ddd/pkg/health"
	pubsub "github.com/shiqinfeng1/goframe-ddd/pkg/pubsub"
	gomock "go.uber.org/mock/gomock"
)

// MockConnIntf is a mock of ConnIntf interface.
type MockConnIntf struct {
	ctrl     *gomock.Controller
	recorder *MockConnIntfMockRecorder
	isgomock struct{}
}

// MockConnIntfMockRecorder is the mock recorder for MockConnIntf.
type MockConnIntfMockRecorder struct {
	mock *MockConnIntf
}

// NewMockConnIntf creates a new mock instance.
func NewMockConnIntf(ctrl *gomock.Controller) *MockConnIntf {
	mock := &MockConnIntf{ctrl: ctrl}
	mock.recorder = &MockConnIntfMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConnIntf) EXPECT() *MockConnIntfMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockConnIntf) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockConnIntfMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockConnIntf)(nil).Close))
}

// Conn mocks base method.
func (m *MockConnIntf) Conn() *nats.Conn {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Conn")
	ret0, _ := ret[0].(*nats.Conn)
	return ret0
}

// Conn indicates an expected call of Conn.
func (mr *MockConnIntfMockRecorder) Conn() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Conn", reflect.TypeOf((*MockConnIntf)(nil).Conn))
}

// NewJetStream mocks base method.
func (m *MockConnIntf) NewJetStream() (jetstream.JetStream, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewJetStream")
	ret0, _ := ret[0].(jetstream.JetStream)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewJetStream indicates an expected call of NewJetStream.
func (mr *MockConnIntfMockRecorder) NewJetStream() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewJetStream", reflect.TypeOf((*MockConnIntf)(nil).NewJetStream))
}

// Status mocks base method.
func (m *MockConnIntf) Status() nats.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(nats.Status)
	return ret0
}

// Status indicates an expected call of Status.
func (mr *MockConnIntfMockRecorder) Status() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockConnIntf)(nil).Status))
}

// MockConnector is a mock of Connector interface.
type MockConnector struct {
	ctrl     *gomock.Controller
	recorder *MockConnectorMockRecorder
	isgomock struct{}
}

// MockConnectorMockRecorder is the mock recorder for MockConnector.
type MockConnectorMockRecorder struct {
	mock *MockConnector
}

// NewMockConnector creates a new mock instance.
func NewMockConnector(ctrl *gomock.Controller) *MockConnector {
	mock := &MockConnector{ctrl: ctrl}
	mock.recorder = &MockConnectorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConnector) EXPECT() *MockConnectorMockRecorder {
	return m.recorder
}

// Connect mocks base method.
func (m *MockConnector) Connect(arg0 string, arg1 ...nats.Option) (ConnIntf, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Connect", varargs...)
	ret0, _ := ret[0].(ConnIntf)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Connect indicates an expected call of Connect.
func (mr *MockConnectorMockRecorder) Connect(arg0 any, arg1 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockConnector)(nil).Connect), varargs...)
}

// MockJetStreamCreator is a mock of JetStreamCreator interface.
type MockJetStreamCreator struct {
	ctrl     *gomock.Controller
	recorder *MockJetStreamCreatorMockRecorder
	isgomock struct{}
}

// MockJetStreamCreatorMockRecorder is the mock recorder for MockJetStreamCreator.
type MockJetStreamCreatorMockRecorder struct {
	mock *MockJetStreamCreator
}

// NewMockJetStreamCreator creates a new mock instance.
func NewMockJetStreamCreator(ctrl *gomock.Controller) *MockJetStreamCreator {
	mock := &MockJetStreamCreator{ctrl: ctrl}
	mock.recorder = &MockJetStreamCreatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJetStreamCreator) EXPECT() *MockJetStreamCreatorMockRecorder {
	return m.recorder
}

// New mocks base method.
func (m *MockJetStreamCreator) New(conn ConnIntf) (jetstream.JetStream, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "New", conn)
	ret0, _ := ret[0].(jetstream.JetStream)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// New indicates an expected call of New.
func (mr *MockJetStreamCreatorMockRecorder) New(conn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "New", reflect.TypeOf((*MockJetStreamCreator)(nil).New), conn)
}

// MockConnectionManagerIntf is a mock of ConnectionManagerIntf interface.
type MockConnectionManagerIntf struct {
	ctrl     *gomock.Controller
	recorder *MockConnectionManagerIntfMockRecorder
	isgomock struct{}
}

// MockConnectionManagerIntfMockRecorder is the mock recorder for MockConnectionManagerIntf.
type MockConnectionManagerIntfMockRecorder struct {
	mock *MockConnectionManagerIntf
}

// NewMockConnectionManagerIntf creates a new mock instance.
func NewMockConnectionManagerIntf(ctrl *gomock.Controller) *MockConnectionManagerIntf {
	mock := &MockConnectionManagerIntf{ctrl: ctrl}
	mock.recorder = &MockConnectionManagerIntfMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConnectionManagerIntf) EXPECT() *MockConnectionManagerIntfMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockConnectionManagerIntf) Close(ctx context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close", ctx)
}

// Close indicates an expected call of Close.
func (mr *MockConnectionManagerIntfMockRecorder) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockConnectionManagerIntf)(nil).Close), ctx)
}

// Connect mocks base method.
func (m *MockConnectionManagerIntf) Connect(ctx context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Connect", ctx)
}

// Connect indicates an expected call of Connect.
func (mr *MockConnectionManagerIntfMockRecorder) Connect(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockConnectionManagerIntf)(nil).Connect), ctx)
}

// GetJetStream mocks base method.
func (m *MockConnectionManagerIntf) GetJetStream() (jetstream.JetStream, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetJetStream")
	ret0, _ := ret[0].(jetstream.JetStream)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetJetStream indicates an expected call of GetJetStream.
func (mr *MockConnectionManagerIntfMockRecorder) GetJetStream() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetJetStream", reflect.TypeOf((*MockConnectionManagerIntf)(nil).GetJetStream))
}

// Health mocks base method.
func (m *MockConnectionManagerIntf) Health() *health.Health {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Health")
	ret0, _ := ret[0].(*health.Health)
	return ret0
}

// Health indicates an expected call of Health.
func (mr *MockConnectionManagerIntfMockRecorder) Health() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Health", reflect.TypeOf((*MockConnectionManagerIntf)(nil).Health))
}

// JsPublish mocks base method.
func (m *MockConnectionManagerIntf) JsPublish(ctx context.Context, subject string, message []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JsPublish", ctx, subject, message)
	ret0, _ := ret[0].(error)
	return ret0
}

// JsPublish indicates an expected call of JsPublish.
func (mr *MockConnectionManagerIntfMockRecorder) JsPublish(ctx, subject, message any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JsPublish", reflect.TypeOf((*MockConnectionManagerIntf)(nil).JsPublish), ctx, subject, message)
}

// Publish mocks base method.
func (m *MockConnectionManagerIntf) Publish(ctx context.Context, subject string, message []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", ctx, subject, message)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish.
func (mr *MockConnectionManagerIntfMockRecorder) Publish(ctx, subject, message any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockConnectionManagerIntf)(nil).Publish), ctx, subject, message)
}

// isConnected mocks base method.
func (m *MockConnectionManagerIntf) isConnected() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "isConnected")
	ret0, _ := ret[0].(bool)
	return ret0
}

// isConnected indicates an expected call of isConnected.
func (mr *MockConnectionManagerIntfMockRecorder) isConnected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "isConnected", reflect.TypeOf((*MockConnectionManagerIntf)(nil).isConnected))
}

// MockJsSubscriptionManagerIntf is a mock of JsSubscriptionManagerIntf interface.
type MockJsSubscriptionManagerIntf struct {
	ctrl     *gomock.Controller
	recorder *MockJsSubscriptionManagerIntfMockRecorder
	isgomock struct{}
}

// MockJsSubscriptionManagerIntfMockRecorder is the mock recorder for MockJsSubscriptionManagerIntf.
type MockJsSubscriptionManagerIntfMockRecorder struct {
	mock *MockJsSubscriptionManagerIntf
}

// NewMockJsSubscriptionManagerIntf creates a new mock instance.
func NewMockJsSubscriptionManagerIntf(ctrl *gomock.Controller) *MockJsSubscriptionManagerIntf {
	mock := &MockJsSubscriptionManagerIntf{ctrl: ctrl}
	mock.recorder = &MockJsSubscriptionManagerIntfMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJsSubscriptionManagerIntf) EXPECT() *MockJsSubscriptionManagerIntfMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockJsSubscriptionManagerIntf) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockJsSubscriptionManagerIntfMockRecorder) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockJsSubscriptionManagerIntf)(nil).Close), ctx)
}

// DeleteSubscriber mocks base method.
func (m *MockJsSubscriptionManagerIntf) DeleteSubscriber(ctx context.Context, streamName, consumerName, topicName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteSubscriber", ctx, streamName, consumerName, topicName)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteSubscriber indicates an expected call of DeleteSubscriber.
func (mr *MockJsSubscriptionManagerIntfMockRecorder) DeleteSubscriber(ctx, streamName, consumerName, topicName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSubscriber", reflect.TypeOf((*MockJsSubscriptionManagerIntf)(nil).DeleteSubscriber), ctx, streamName, consumerName, topicName)
}

// NewSubscriber mocks base method.
func (m *MockJsSubscriptionManagerIntf) NewSubscriber(stream streamIntf, streamName, consumerName, topicName string, consumeType SubType) *jsSubscriber {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewSubscriber", stream, streamName, consumerName, topicName, consumeType)
	ret0, _ := ret[0].(*jsSubscriber)
	return ret0
}

// NewSubscriber indicates an expected call of NewSubscriber.
func (mr *MockJsSubscriptionManagerIntfMockRecorder) NewSubscriber(stream, streamName, consumerName, topicName, consumeType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewSubscriber", reflect.TypeOf((*MockJsSubscriptionManagerIntf)(nil).NewSubscriber), stream, streamName, consumerName, topicName, consumeType)
}

// Subscribe mocks base method.
func (m *MockJsSubscriptionManagerIntf) Subscribe(ctx context.Context, streamName, consumerName, topicName string, handler pubsub.SubscribeFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", ctx, streamName, consumerName, topicName, handler)
	ret0, _ := ret[0].(error)
	return ret0
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockJsSubscriptionManagerIntfMockRecorder) Subscribe(ctx, streamName, consumerName, topicName, handler any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockJsSubscriptionManagerIntf)(nil).Subscribe), ctx, streamName, consumerName, topicName, handler)
}

// MockSubscriptionManagerIntf is a mock of SubscriptionManagerIntf interface.
type MockSubscriptionManagerIntf struct {
	ctrl     *gomock.Controller
	recorder *MockSubscriptionManagerIntfMockRecorder
	isgomock struct{}
}

// MockSubscriptionManagerIntfMockRecorder is the mock recorder for MockSubscriptionManagerIntf.
type MockSubscriptionManagerIntfMockRecorder struct {
	mock *MockSubscriptionManagerIntf
}

// NewMockSubscriptionManagerIntf creates a new mock instance.
func NewMockSubscriptionManagerIntf(ctrl *gomock.Controller) *MockSubscriptionManagerIntf {
	mock := &MockSubscriptionManagerIntf{ctrl: ctrl}
	mock.recorder = &MockSubscriptionManagerIntfMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSubscriptionManagerIntf) EXPECT() *MockSubscriptionManagerIntfMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockSubscriptionManagerIntf) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockSubscriptionManagerIntfMockRecorder) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSubscriptionManagerIntf)(nil).Close), ctx)
}

// DeleteSubscriber mocks base method.
func (m *MockSubscriptionManagerIntf) DeleteSubscriber(ctx context.Context, topicName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteSubscriber", ctx, topicName)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteSubscriber indicates an expected call of DeleteSubscriber.
func (mr *MockSubscriptionManagerIntfMockRecorder) DeleteSubscriber(ctx, topicName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSubscriber", reflect.TypeOf((*MockSubscriptionManagerIntf)(nil).DeleteSubscriber), ctx, topicName)
}

// NewSubscriber mocks base method.
func (m *MockSubscriptionManagerIntf) NewSubscriber(conn *nats.Conn, topicName string, consumeType SubType) *subscriber {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewSubscriber", conn, topicName, consumeType)
	ret0, _ := ret[0].(*subscriber)
	return ret0
}

// NewSubscriber indicates an expected call of NewSubscriber.
func (mr *MockSubscriptionManagerIntfMockRecorder) NewSubscriber(conn, topicName, consumeType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewSubscriber", reflect.TypeOf((*MockSubscriptionManagerIntf)(nil).NewSubscriber), conn, topicName, consumeType)
}

// Subscribe mocks base method.
func (m *MockSubscriptionManagerIntf) Subscribe(ctx context.Context, topicName string, handler pubsub.SubscribeFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", ctx, topicName, handler)
	ret0, _ := ret[0].(error)
	return ret0
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockSubscriptionManagerIntfMockRecorder) Subscribe(ctx, topicName, handler any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockSubscriptionManagerIntf)(nil).Subscribe), ctx, topicName, handler)
}
